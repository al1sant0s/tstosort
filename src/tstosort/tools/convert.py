import argparse
import os
import xml.etree.ElementTree as ET
import locale
import re
from pathlib import Path
from natsort import natsorted
from operator import itemgetter
from colorama import Fore, Style, init


LANGUAGE_REQUIREMENTS = {
    "en": "ENG_US",
    "fr": "FRE_FR",
    "it": "ITA_IT",
    "de": "GER_DE",
    "es": "SPA_ES",
    "ko": "KOR_KR",
    "zh": "CHS_CN",
    "pt": "POR_BR",
    "ru": "RUS_RU",
    "tc": "CHT_CN",
    "da": "DAN_DK",
    "sv": "SWE_SE",
    "no": "NOR_NO",
    "du": "DUT_NL",
    "tr": "TUR_TR",
    "th": "THA_TH"
}


LOCALES = {
    "en": "en_US.UTF-8"}
#    "en": "en_US.UTF-8",
#    "da": "da_DK.ISO8859-1",
#    "de": "de_DE.ISO8859-1",
#    "es": "es_DO.ISO8859-1",
#    "fr": "fr_FR.ISO8859-1",
#    "it": "it_IT.ISO8859-1",
#    "ko": "ko_KR.eucKR",
#    "nl": "nl_NL.ISO8859-1",
#    "no": "no_NO.ISO8859-1",
#    "pt": "pt_BR.ISO8859-1",
#    "ru": "ru_RU.UTF-8",
#    "sv": "sv_SE.ISO8859-1",
#    "tc": "zh_CN.eucCN",
#    "th": "th_TH.TIS620",
#    "tr": "tr_TR.ISO8859-9",
#    "zh": "zh_CN.eucCN"
#}


SCORPIO_INDEX_PREFIX = {"bld_": "0", "cha_": "1", "mtx_": "6", "ui_": "14",  "": "15"}
SCORPIO_PREFIX_TYPES = {"building": "bld_", "character": "cha_"}
SCORPIO_FAKE_PREFIX_TYPES = {"consumable": "con_", "gameobjectbundle": "gob_"}


MASTERLISTS = {"building": "buildingmasterlist.xml", "character": "charactermasterlist.xml", "gameobjectbundle": "gameobjectbundlesmasterlist.xml", "consumable": "consumablemasterlist.xml"}
FILE_PREFIX = "autogenerated_"

def CONTROL_VARIABLE(x):
    return f"AUTOGENERATED_SORT_{x}_ENABLE"


def colorprint(style, message, end="\n"):
    print(style + message, end=end)
    print(Style.RESET_ALL)



def get_textpool(directory, obj):

    # Open adequate masterlist file.
    id = int(obj.attrib["id"])
    obj_type = obj.attrib["type"].lower()
    name = obj.attrib["name"].lower()
    textpoolname = ""
    
    masterlist = Path(directory, MASTERLISTS[obj_type])
    tree = ET.parse(masterlist)
    root = tree.getroot()

    idmasterlist = root.find("IDMasterList")

    if idmasterlist is None:
        return {"prefix": "", "suffix": "*1"}

    for package in idmasterlist.findall("Package"):

        rangefrom = int(package.attrib.get("rangeFrom", "0"))
        rangeto = int(package.attrib.get("rangeTo", "0"))

        if rangefrom <= id and id <= rangeto:
            subtree = ET.parse(Path(directory, package.attrib["name"].lower() + ".xml"))
            subroot = subtree.getroot()

            elements = [element for element in subroot.findall("*") if element.tag.lower() == obj_type]

            for element in elements:
                if int(element.attrib["id"]) == id:
                    textpoolname = element.attrib.get("textpoolName")

                    if textpoolname is not None:

                        textpoolname = textpoolname.lower()

                        # Try to get prefix.
                        textpoolname_split = textpoolname.split("_", maxsplit = 1)
                        prefix = textpoolname_split[0] + "_"

                        if prefix in SCORPIO_INDEX_PREFIX:
                            return {"prefix": prefix, "suffix": textpoolname.strip(prefix)}

                        else:
                            return {"prefix": "", "suffix": textpoolname}


                    else:

                        prefix = SCORPIO_PREFIX_TYPES.get(obj_type, "")
                        suffix = name + "_name"

                        if prefix == "":
                            suffix = SCORPIO_FAKE_PREFIX_TYPES.get(obj_type, "") + suffix

                        return {"prefix": prefix, "suffix": suffix}


    # Fall back to this if no textpool can be determined.
    return {"prefix": "", "suffix": "*1"}




def get_item_name(directory, lang, obj):

    textpoolname = get_textpool(directory, obj)
    item_index = SCORPIO_INDEX_PREFIX[textpoolname["prefix"]]

    # Make sure to match the exact file.
    pattern = re.compile(f".*[^1]{item_index}.xml")

    for textpool_dir in Path(directory.parent).glob(f"*-{lang}"):
        for scorpio_file in textpool_dir.rglob(f"*{item_index}.xml"):

            if pattern.match(scorpio_file.name):

                with open(scorpio_file, "rb") as f:
                    root = ET.fromstring(f.read().decode("utf8"))

                    for group in root.findall("group"):

                        if group.attrib.get("prefix", "") == textpoolname["prefix"]:
                            for item in group.findall("item"):
                                if item.attrib.get("suffix", "") == textpoolname["suffix"]:
                                    return item.text


    # Fall back to this if no textpool can be determined.
    return "*1"




def map_objsets_to_objs(include, parent_dir):

    objsets = dict()

    if include.attrib["path"] is None:
        return objsets


    pathsplit = include.attrib["path"].split(":")
    submenu = Path(parent_dir, pathsplit[0].lower())

    if submenu.exists() is False:
        return objsets

    if pathsplit[-1].capitalize() != "Objects":
        return objsets


    subtree = ET.parse(submenu)
    subroot = subtree.getroot()


    objs = subroot

    for component in pathsplit[2:]:
        objs = objs.find(component) # type: ignore


    if objs is None:
        return objsets


    for objset in objs.findall("*"):

        obj = objset.find("Object")
        if obj is None:
            continue

        objsets[objset.attrib.get("name")] = obj


    return objsets



def get_items_from_category(directory, category, items, objsets, lang, indent):

    # Make sure this category will stick to our sorting.
    category.attrib["sortList"] = "false"
    category.attrib["newestFirst"] = "false"

    for include in category.findall("Include"):
        objsets.update(map_objsets_to_objs(include, directory))


    # Add all listed objects and object sets.
    for obj in [element for element in category.findall("*") if element.tag.startswith("Object")]:
        sub_obj = obj

        if obj.tag != "Object":
            sub_obj = objsets.get(obj.attrib["name"])
            if sub_obj is None:
                continue

        item_name = get_item_name(directory, lang, sub_obj)
        items.append((obj, item_name))



    # Include objects.
    for include in category.findall("Include"):

        if include.attrib["path"] is None:
            continue

        pathsplit = include.attrib["path"].split(":")
        include_file = Path(directory, pathsplit[0].lower())

        if include_file.exists() is False:
            continue

        if pathsplit[-1].capitalize() == "Objects":
            continue


        include_tree = ET.parse(include_file)
        include_root = include_tree.getroot()
        section = include_root

        for element in pathsplit[2:]:
            section = section.find(element) # type: ignore


        if section is None:
            continue


        # Try to load a existing file for the language. Otherwise, create a new one.
        target = Path(directory, FILE_PREFIX + lang + "_" + include_file.name)
        root = ET.Element(include_root.tag, include_root.attrib)
        tree = ET.ElementTree(root)

        if target.exists() is True:
            tree = ET.parse(target)
            root = tree.getroot()


        includes = root.find("AutoIncludes")
        if includes is None:
            includes = ET.SubElement(root, "AutoIncludes")


        # Add all listed objects and object sets.
        for obj in [element for element in section.findall("*") if element.tag.startswith("Object")]:
            sub_obj = obj

            if obj.tag != "Object":
                sub_obj = objsets.get(obj.attrib["name"])
                if sub_obj is None:
                    continue

            # Add objectset to include section.
            ET.SubElement(includes, obj.attrib["name"]).append(obj)
            obj = ET.Element("Include", attrib = {"path": f"{target.name}:{root.tag}:AutoIncludes:{obj.attrib["name"]}"})
            obj.extend(list(include.findall("*")))

            item_name = get_item_name(directory, lang, sub_obj)
            items.append((obj, item_name))


        # Store tree.
        ET.indent(tree, " " * indent)
        tree.write(target)


    return items



def sort_menu(storemenu, indent):

    gamescripts = storemenu.parent

    if storemenu.exists() is True:

        load_tree = ET.parse(storemenu)
        load_root = load_tree.getroot()

        load_include = load_root.find("Include")

        if load_include is None:
            return False


        if load_include.attrib["path"] is None:
            return False


        pathsplit = load_include.attrib["path"].split(":")
        main_menu = Path(gamescripts, pathsplit[0].lower())


        if main_menu.exists() is False:
            return False


        main_tree = ET.parse(main_menu)
        main_root = main_tree.getroot()

        new_root = ET.Element("StoreMenus") 
        new_tree = ET.ElementTree(new_root)
        subelement = ET.SubElement(new_root, "Include", load_include.attrib)
        requirements = ET.SubElement(subelement, "Requirements")
        ET.SubElement(requirements, "Requirement", attrib = {"type": "formula", "formula": f"{CONTROL_VARIABLE(storemenu.stem.upper())}==0"})

        print("YES")

        # Remove all autogenerated files.
        for file in gamescripts.glob(f"{FILE_PREFIX}*"):
            os.remove(file)


        # Iterate first over all objs.
        objsets = dict()
        for include in main_root.findall("Include"):
            objsets.update(map_objsets_to_objs(include, gamescripts))


        # With all objects read, iterate over all categories and includes and modify one by one per language.

        for lang in LOCALES.keys():

            colorprint(Style.BRIGHT + Fore.RED, " " * 1 * indent + f" - Language {Fore.YELLOW + lang}:", "")

            # Set locale.
            try:
                locale.setlocale(locale.LC_COLLATE, LOCALES[lang])
            except locale.Error as e:
                print(f"Locale setting {e} failed: {LOCALES[lang]}. Falling back to default Unicode sort.")

            for element in main_root.findall("*"):

                if element.tag == "Category":

                    if element.attrib.get("file") is None:
                        return False

                    submenu_file = Path(gamescripts, element.attrib["file"].lower())

                    if submenu_file.exists() is False:
                        return False

                    # Load the category file.
                    submenu_tree = ET.parse(submenu_file)
                    submenu_root = submenu_tree.getroot()

                    # Create the new file.
                    target = Path(gamescripts, FILE_PREFIX + lang + "_" + submenu_file.name)
                    root = ET.Element(submenu_root.tag, submenu_root.attrib)
                    tree = ET.ElementTree(root)

                    items = list()
                    items = get_items_from_category(gamescripts, submenu_root, items, objsets, lang, indent)

                    # Sort all items.
                    for item in natsorted(items, key = itemgetter(1)):
                        root.append(item[0])


                    # Store tree.
                    ET.indent(tree, " " * indent)
                    tree.write(target)
                    colorprint(Style.BRIGHT + Fore.LIGHTBLACK_EX, " " * 2 * indent + f" - {target.name}", "")


                    # Make sure this category will stick to our sorting.
                    element.attrib["sortList"] = "false"
                    element.attrib["newestFirst"] = "false"
                    element.attrib["file"] = str(target.name)



                elif element.tag == "Include":

                    if element.attrib.get("path") is None:
                        return False


                    pathsplit = element.attrib.get("path", "").split(":")

                    include_file = Path(gamescripts, pathsplit[0].lower())

                    if include_file.exists() is False:
                        return False


                    include_tree = ET.parse(include_file)
                    include_root = include_tree.getroot()
                    section = include_root

                    for component in pathsplit[2:]:
                        section = section.find(component) # type: ignore


                    if section is None:
                        return False


                    if section.tag.capitalize() != "Categories":
                        return False


                    # Try to load a existing file for the language. Otherwise, create a new one.
                    target = Path(gamescripts, FILE_PREFIX + lang + "_" + include_file.name)
                    root = ET.Element(include_root.tag, include_root.attrib)
                    tree = ET.ElementTree(root)

                    if target.exists() is True:
                        tree = ET.parse(target)
                        root = tree.getroot()


                    categories = ET.SubElement(root, section.tag, section.attrib)

                    for category in section.findall("Category"):

                        items = list()
                        items = get_items_from_category(gamescripts, category, items, objsets, lang, indent)
                        new_category = ET.SubElement(categories, category.tag, category.attrib)

                        # Sort all items.
                        for item in natsorted(items, key = itemgetter(1)):
                            new_category.append(item[0])


                    # Store tree.
                    ET.indent(tree, " " * indent)
                    tree.write(target)
                    colorprint(Style.BRIGHT + Fore.LIGHTBLACK_EX, " " * 2 * indent + f" - {target.name}", "")

                    element.attrib["path"] = ":".join([str(target.name)] + pathsplit[1:])


            # Store storemenu for this language.
            target = Path(gamescripts, FILE_PREFIX + lang + "_" + main_menu.name)
            ET.indent(main_tree, " " * indent)
            main_tree.write(target)


            # Include new file created for this language.
            subelement = ET.SubElement(new_root, "Include", {"path": str(target.name) + ":" + main_root.tag})

            # Add requirements.
            requirements = ET.SubElement(subelement, "Requirements")
            ET.SubElement(requirements, "Requirement", attrib = {"type": "formula", "formula": f"{CONTROL_VARIABLE_STOREMENU}==1"})
            ET.SubElement(requirements, "Requirement", attrib = {"type": "language", "language": LANGUAGE_REQUIREMENTS[lang]})



        # Store tree.
        ET.indent(new_tree, " " * indent)
        new_tree.write(storemenu)

        return True

    else:
        return False


def main():
    parser = argparse.ArgumentParser(
        description="""
        This tool allows you to sort the storemenu files in alphabetically order for the game 'The Simpsons: Tapped Out'.
        """,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "-r",
        "--reverse",
        help="If set, reverse the order.",
        action="store_true",
    )

    parser.add_argument(
        "-i",
        "--indent",
        help="Indent level value used for xml files.",
        default=2,
        type=int,
    )

    parser.add_argument(
        "input_dir",
        help="List of the DLCs directories containing the gamescripts and textpools files.",
        nargs="+",
    )


    # Init colorama.
    init()

    args = parser.parse_args()
    directories = [Path(item) for item in args.input_dir]

    # Get total of DLCS to sort.
    total = len(directories)

    for i in range(len(directories)):

        directory = directories[i]

        gamescripts = Path(directory, "gamescripts")
        storemenu = Path(gamescripts, "storemenu.xml")
        inventory = Path(gamescripts, "inventorylists.xml")

        # Process the files.
        colorprint(Style.BRIGHT + Fore.GREEN, f" -> Sorting StoreMenu files from DLC: {Fore.WHITE + directory.name}", "")
        sort_menu(storemenu, args.indent)


        # Process the files.
        colorprint(Style.BRIGHT + Fore.GREEN, f" -> Sorting Inventory files from DLC: {Fore.WHITE + directory.name}", "")
        sort_menu(inventory, args.indent)





