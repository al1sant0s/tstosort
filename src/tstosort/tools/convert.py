import argparse
import os
import xml.etree.ElementTree as ET
import locale
import re
import copy
from pathlib import Path
from natsort import natsorted
from operator import itemgetter
from colorama import Fore, Style, init


LANGUAGE_REQUIREMENTS = {
    "en": "ENG_US",
    "fr": "FRE_FR",
    "it": "ITA_IT",
    "de": "GER_DE",
    "es": "SPA_ES",
    "ko": "KOR_KR",
    "zh": "CHS_CN",
    "pt": "POR_BR",
    "ru": "RUS_RU",
    "tc": "CHT_CN",
    "da": "DAN_DK",
    "sv": "SWE_SE",
    "no": "NOR_NO",
    "nl": "DUT_NL",
    "tr": "TUR_TR",
    "th": "THA_TH"
}


LOCALES = {
    "en": "en_US.UTF-8",
    "da": "da_DK.ISO8859-1",
    "de": "de_DE.ISO8859-1",
    "es": "es_DO.ISO8859-1",
    "fr": "fr_FR.ISO8859-1",
    "it": "it_IT.ISO8859-1",
    "ko": "ko_KR.eucKR",
    "nl": "nl_NL.ISO8859-1",
    "no": "no_NO.ISO8859-1",
    "pt": "pt_BR.ISO8859-1",
    "ru": "ru_RU.UTF-8",
    "sv": "sv_SE.ISO8859-1",
    "tc": "zh_CN.eucCN",
    "th": "th_TH.TIS620",
    "tr": "tr_TR.ISO8859-9",
    "zh": "zh_CN.eucCN"
}


SCORPIO_INDEX_PREFIX = {"bld_": "0", "cha_": "1", "mtx_": "6", "qst_dq_": "9", "qst_": "10", "ui_": "14",  "": "15"}
SCORPIO_PREFIX_TYPES = {"building": "bld_", "decoration": "bld_", "character": "cha_", "characterskin": "cha_", "buildingskin": "bld_"}
SCORPIO_FAKE_PREFIX_TYPES = {"consumable": "con_", "gameobjectbundle": "gob_"}
DEFAULT_MAIN_MENU_PREFIX = "main"
FILE_PREFIX = "autogenerated_"
MASTERLISTS = {
    "building": "buildingmasterlist.xml",
    "character": "charactermasterlist.xml",
    "characterskin": "characterskinmasterlist.xml",
    "gameobjectbundle": "gameobjectbundlesmasterlist.xml",
    "consumable": "consumablemasterlist.xml"
}


def CONTROL_VARIABLE(x):
    return f"AUTOGENERATED_SORT_{x}_ENABLE"


def colorprint(style, message, end="\n"):
    print(style + message, end=end)
    print(Style.RESET_ALL)


def get_item_name(directory, lang, prefix, suffix):

    # Make sure to match the exact file.
    pattern = re.compile(f".*[^1]{SCORPIO_INDEX_PREFIX[prefix]}.xml")

    for textpool_dir in Path(directory.parent).glob(f"*-{lang}"):
        for scorpio_file in textpool_dir.rglob(f"*{SCORPIO_INDEX_PREFIX[prefix]}.xml"):

            if pattern.match(scorpio_file.name):

                with open(scorpio_file, "rb") as f:
                    root = ET.fromstring(f.read().decode("utf8"))

                    for group in root.findall("group"):

                        group_prefix = group.attrib.get("prefix", "")
                        if prefix in group_prefix:

                            precede = group_prefix.removeprefix(prefix)

                            if precede in suffix:
                                search_suffix = suffix.removeprefix(precede)

                                for item in group.findall("item"):
                                    if search_suffix == item.attrib.get("suffix", ""):
                                        return item.text

    return False


def get_textpool(directory, lang, obj):

    prefix = ""
    suffix = ""

    # Open adequate masterlist file.
    id = int(obj.attrib.get("id", "-1"))
    obj_type = obj.attrib.get("type", "").lower()
    name = obj.attrib.get("name", "").lower()

    if MASTERLISTS.get(obj_type) is not None:

        masterlist = Path(directory, MASTERLISTS[obj_type])
        tree = ET.parse(masterlist)
        root = tree.getroot()

        idmasterlist = root.find("IDMasterList")

        if idmasterlist is None:
            return "*1"

        for package in idmasterlist.findall("Package"):

            rangefrom = int(package.attrib.get("rangeFrom", "0"))
            rangeto = int(package.attrib.get("rangeTo", "0"))

            if rangefrom <= id and id <= rangeto:
                subtree = ET.parse(Path(directory, package.attrib["name"].lower() + ".xml"))
                subroot = subtree.getroot()

                for element in subroot.findall("*"):
                    if int(element.attrib.get("id", -1)) == id:

                        # Override textpool if specified.
                        textpoolname = element.attrib.get(
                            "textpoolName",
                            element.attrib.get(
                                "customTitle",
                                element.attrib.get("title")
                            )
                        )


                        if textpoolname is not None:

                            # Try to get prefix.
                            textpoolname = textpoolname.lower()
                            suffix = textpoolname

                            # Get the biggest prefix possible from the list of all available prefixes.
                            for scorpio_prefix in SCORPIO_INDEX_PREFIX.keys():
                                last_piece = textpoolname.removeprefix(scorpio_prefix)
                                if last_piece != textpoolname and  len(scorpio_prefix) > len(prefix):
                                    prefix = scorpio_prefix


                            if prefix != "":
                                suffix = suffix.removeprefix(prefix)


                        else:

                            # Override the name and get the secondary type if possible.
                            name = element.attrib.get("name", obj.attrib.get("name", ""))
                            name = name.lower() # type: ignore
                            second_type = element.attrib.get("type", "").lower()

                            prefix = SCORPIO_PREFIX_TYPES.get(obj_type, SCORPIO_PREFIX_TYPES.get(second_type, ""))
                            suffix = name + "_name"

                            # Override prefix and suffix if additional attributes are present.
                            if second_type == "characterskin" or second_type == "buildingskin":
                                skin = element.get("skin")
                                if skin is not None:
                                    suffix = skin.lower() + "_name"

                            # Last alternative only for items without prefixes like reward consumables.
                            elif prefix == "" :
                                suffix = SCORPIO_FAKE_PREFIX_TYPES.get(obj_type, "") + suffix


    else:

        textpoolname = obj.attrib.get(
            "textpoolName",
            obj.attrib.get(
                "customTitle",
                obj.attrib.get("title")
            )
        )

        if textpoolname is not None:

            # Try to get prefix.
            textpoolname = textpoolname.lower()
            suffix = textpoolname

            # Get the biggest prefix possible from the list of all available prefixes.
            for scorpio_prefix in SCORPIO_INDEX_PREFIX.keys():
                last_piece = textpoolname.removeprefix(scorpio_prefix)
                if last_piece != textpoolname and  len(scorpio_prefix) > len(prefix):
                    prefix = scorpio_prefix


            if prefix != "":
                suffix = suffix.removeprefix(prefix)


    # If it doesn't work the first attempt, try again in the misc section.
    item_name = get_item_name(directory, lang, prefix, suffix)
    if item_name is not False:
        return item_name

    else:
        prefix = ""
        suffix = SCORPIO_FAKE_PREFIX_TYPES.get(obj_type, "") + name + "_name"
        item_name = get_item_name(directory, lang, prefix, suffix)

        if item_name is False:
            return "*1"

        else:
            return item_name


def map_objsets_to_objs(include, parent_dir):

    objsets = dict()

    if include.attrib["path"] is None:
        return objsets


    pathsplit = include.attrib["path"].split(":")
    submenu = Path(parent_dir, pathsplit[0].lower())

    if submenu.exists() is False:
        return objsets

    if pathsplit[-1].capitalize() != "Objects":
        return objsets


    subtree = ET.parse(submenu)
    subroot = subtree.getroot()
    section = subroot

    for component in pathsplit[2:]:
        section = section.find(component) # type: ignore


    if section is None:
        return objsets


    for objset in section.findall("*"):

        if objset.tag == "ScriptObject":
            obj = ET.Element("Object", attrib = {"id": "-1", "type": "scriptobject", "name": objset.attrib.get("name", ""), "title": objset.attrib.get("title", "")})
            objsets[objset.attrib.get("name")] = obj

        else:
            obj = objset.find("Object")
            if obj is None:
                continue

            objsets[objset.attrib.get("name")] = obj


    return objsets



def get_items_from_category(directory, category, items, objsets, lang, indent):


    # Make sure this category will stick to our sorting.
    category.attrib["sortList"] = "false"
    category.attrib["newestFirst"] = "false"


    for include in category.findall("Include"):
        objsets.update(map_objsets_to_objs(include, directory))


    # Add all listed objects and object sets.
    for obj in [element for element in category.findall("*") if "Object" in element.tag]:
        sub_obj = obj

        if obj.tag != "Object":
            sub_obj = objsets.get(obj.attrib["name"])
            if sub_obj is None:
                continue


        item_name = get_textpool(directory, lang, sub_obj)
        items.append((obj, item_name))



    # Include objects.
    for include in category.findall("Include"):

        if include.attrib["path"] is None:
            continue

        pathsplit = include.attrib["path"].split(":")
        include_file = Path(directory, pathsplit[0].lower())

        if include_file.exists() is False:
            continue

        if pathsplit[-1].capitalize() == "Objects":
            continue


        include_tree = ET.parse(include_file)
        include_root = include_tree.getroot()
        section = include_root

        for element in pathsplit[2:]:
            section = section.find(element) # type: ignore


        if section is None:
            continue


        # Try to load a existing file for the language. Otherwise, create a new one.
        target = Path(directory, FILE_PREFIX + lang + "_" + include_file.name)
        root = ET.Element(include_root.tag, include_root.attrib)
        tree = ET.ElementTree(root)

        if target.exists() is True:
            tree = ET.parse(target)
            root = tree.getroot()


        includes = root.find("AutoIncludes")
        if includes is None:
            includes = ET.SubElement(root, "AutoIncludes")


        # Add all listed objects and object sets.
        for obj in [element for element in section.findall("*") if element.tag.startswith("Object")]:
            sub_obj = obj

            if obj.tag != "Object":
                sub_obj = objsets.get(obj.attrib["name"])
                if sub_obj is None:
                    continue

            # Add objectset to include section.
            if includes.find(obj.tag) is None:
                ET.SubElement(includes, obj.attrib["name"]).append(obj)
                obj = ET.Element("Include", attrib = {"path": f"{target.name}:{root.tag}:AutoIncludes:{obj.attrib["name"]}"})
                obj.extend(list(include.findall("*")))

            item_name = get_textpool(directory, lang, sub_obj)
            items.append((obj, item_name))


        # Store tree.
        ET.indent(tree, " " * indent)
        tree.write(target)


    return items



def sort_menu(storemenu, languages, indent, debug = False):

    if languages is not None:
        languages = {language: LOCALES[language] for language in languages if language in LOCALES}
        if len(languages) == 0:
            languages = LOCALES

    else:
        languages = LOCALES


    gamescripts = storemenu.parent

    if storemenu.exists() is True:

        load_tree = ET.parse(storemenu)
        load_root = load_tree.getroot()

        # If storemenu file is the normal one, move the file and make a new one.
        if load_root.find("Category") is not None:
            ET.indent(load_tree, " " * indent)
            target = Path(gamescripts, DEFAULT_MAIN_MENU_PREFIX + storemenu.name)
            load_tree.write(target)

            load_root = ET.Element("StoreMenus")
            ET.SubElement(load_root, "Include", attrib = {"path": f"{target.name}:StoreMenus"})
            load_tree = ET.ElementTree(load_root)

        load_include = load_root.find("Include")

        if load_include is None:
            return False


        if load_include.attrib["path"] is None:
            return False


        pathsplit = load_include.attrib["path"].split(":")
        sub_menu = Path(gamescripts, pathsplit[0].lower())


        if sub_menu.exists() is False:
            return False


        sub_tree = ET.parse(sub_menu)
        sub_root = sub_tree.getroot()

        main_root = ET.Element("StoreMenus")
        main_tree = ET.ElementTree(main_root)
        subelement = ET.SubElement(main_root, "Include", load_include.attrib)
        requirements = ET.SubElement(subelement, "Requirements")
        ET.SubElement(requirements, "Requirement", attrib = {"type": "formula", "formula": f"{CONTROL_VARIABLE(storemenu.stem.upper())}==0"})


        # Iterate first over all objs.
        objsets = dict()
        for include in sub_root.findall("Include"):
            objsets.update(map_objsets_to_objs(include, gamescripts))


        # With all objects read, iterate over all categories and includes and modify one by one per language.

        for lang in languages.keys():

            colorprint(Style.BRIGHT + Fore.WHITE, " " * 1 * indent + f" - Language [{" ".join([Fore.GREEN + "'" + language + "'" if lang == language else Fore.WHITE + language for language in languages])}{Fore.WHITE}]:", "")

            # Set locale.
            try:
                locale.setlocale(locale.LC_COLLATE, LOCALES[lang])
            except locale.Error as e:
                print(f"Locale setting {e} failed: {LOCALES[lang]}. Falling back to default Unicode sort.")


            target_tree = copy.deepcopy(sub_tree)
            target_root = target_tree.getroot()

            for element in target_root.findall("*"):

                if element.tag == "Category":

                    if element.attrib.get("file") is None:
                        continue


                    submenu_file = Path(gamescripts, element.attrib["file"].lower())

                    if submenu_file.exists() is False:
                        continue

                    # Load the category file.
                    submenu_tree = ET.parse(submenu_file)
                    submenu_root = submenu_tree.getroot()

                    # Create the new file.
                    target = Path(gamescripts, FILE_PREFIX + lang + "_" + submenu_file.name)
                    root = ET.Element(submenu_root.tag, submenu_root.attrib)
                    tree = ET.ElementTree(root)

                    # Add requirements if any.
                    requirements = submenu_root.find("Requirements")
                    if requirements is not None:
                        root.append(requirements)

                    requirement = submenu_root.find("Requirement")
                    if requirement is not None:
                        root.append(requirement)

                    items = list()
                    items = get_items_from_category(gamescripts, submenu_root, items, objsets, lang, indent)

                    # Sort all items.
                    for item in natsorted(items, key = itemgetter(1)):
                        root.append(item[0])

                        # For debug purposes.
                        if debug is True:
                            root[-1].attrib["text"] = item[1]


                    # Store tree.
                    ET.indent(tree, " " * indent)
                    tree.write(target)
                    colorprint(Style.BRIGHT + Fore.LIGHTBLACK_EX, " " * 2 * indent + f" - {target.name}", "")


                    # Make sure this category will stick to our sorting.
                    element.attrib["sortList"] = "false"
                    element.attrib["newestFirst"] = "false"
                    element.attrib["file"] = str(target.name)



                elif element.tag == "Include":

                    if element.attrib.get("path") is None:
                        continue


                    pathsplit = element.attrib.get("path", "").split(":")

                    include_file = Path(gamescripts, pathsplit[0].lower())

                    if include_file.exists() is False:
                        continue


                    include_tree = ET.parse(include_file)
                    include_root = include_tree.getroot()
                    section = include_root

                    for component in pathsplit[2:]:
                        section = section.find(component) # type: ignore


                    if section is None:
                        continue


                    if section.tag.capitalize() != "Categories":
                        continue


                    # Try to load a existing file for the language. Otherwise, create a new one.
                    target = Path(gamescripts, FILE_PREFIX + lang + "_" + include_file.name)
                    root = ET.Element(include_root.tag, include_root.attrib)
                    tree = ET.ElementTree(root)

                    if target.exists() is True:
                        tree = ET.parse(target)
                        root = tree.getroot()


                    categories = root.find(section.tag)
                    if categories is None:
                        categories = ET.SubElement(root, section.tag, section.attrib)

                    for category in section.findall("Category"):

                        items = list()
                        items = get_items_from_category(gamescripts, category, items, objsets, lang, indent)

                        # Get the first category it can find.
                        all_categories = [ctg for ctg in categories.findall("Category") if ctg.attrib.get("name") == category.attrib.get("name")]
                        main_category = None

                        if len(all_categories) > 0:
                            main_category = all_categories[0]

                        else:
                            main_category = ET.SubElement(categories, category.tag, category.attrib)

                            # Add requirements if any.
                            requirements = category.find("Requirements")
                            if requirements is not None:
                                main_category.append(requirements)

                            requirement = category.find("Requirement")
                            if requirement is not None:
                                main_category.append(requirement)


                        # Sort all items.
                        for item in natsorted(items, key = itemgetter(1)):
                            main_category.append(item[0])

                            # For debug purposes.
                            if debug is True:
                                main_category[-1].attrib["text"] = item[1]


                    # Store tree.
                    ET.indent(tree, " " * indent)
                    tree.write(target)
                    colorprint(Style.BRIGHT + Fore.LIGHTBLACK_EX, " " * 2 * indent + f" - {target.name}", "")

                    element.attrib["path"] = ":".join([str(target.name)] + pathsplit[1:])


            # Store storemenu for this language.
            target = Path(gamescripts, FILE_PREFIX + lang + "_" + sub_menu.name)
            ET.indent(target_tree, " " * indent)
            target_tree.write(target)


            # Include new file created for this language.
            subelement = ET.SubElement(main_root, "Include", {"path": str(target.name) + ":" + target_root.tag})

            # Add requirements.
            requirements = ET.SubElement(subelement, "Requirements")
            ET.SubElement(requirements, "Requirement", attrib = {"type": "formula", "formula": f"{CONTROL_VARIABLE(storemenu.stem.upper())}==1"})
            ET.SubElement(requirements, "Requirement", attrib = {"type": "language", "language": LANGUAGE_REQUIREMENTS[lang]})



        # Store tree.
        ET.indent(main_tree, " " * indent)
        main_tree.write(storemenu)

        return True

    else:
        return False


def main():
    parser = argparse.ArgumentParser(
        description="""
        This tool allows you to sort the storemenu files in alphabetically order for the game 'The Simpsons: Tapped Out'.
        """,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )


    parser.add_argument(
        "-n",
        "--inventory",
        help="If set, sort inventory files as well.",
        action="store_true",
    )


    parser.add_argument(
        "--debug",
        help="Store textpools contents in the objects.",
        action="store_true",
    )

    parser.add_argument(
        "-l",
        "--language",
        help="""
        Specify some specific languages. Available options are:
        en fr, it, de, es, ko, zh, pt, ru, tc, da, sv, no, nl, tr, th.
        """,
        nargs="+"
    )

    parser.add_argument(
        "-i",
        "--indent",
        help="Indent level value used for xml files.",
        default=2,
        type=int,
    )

    parser.add_argument(
        "-d",
        "--directories",
        help="List of the DLCs directories containing the gamescripts and textpools files.",
        nargs="+",
        required = True
    )


    # Init colorama.
    init()

    args = parser.parse_args()
    directories = [Path(item) for item in args.directories]

    # Get total of DLCS to sort.
    total = len(directories)

    for i in range(len(directories)):

        directory = directories[i]

        gamescripts = Path(directory, "gamescripts")
        storemenu = Path(gamescripts, "storemenu.xml")
        inventory = Path(gamescripts, "inventorylists.xml")

        if gamescripts.exists() is False:
            colorprint(Style.BRIGHT + Fore.RED, f" [!] {gamescripts} does not exist!", "")
            continue


        # Remove all autogenerated files.
        for file in gamescripts.glob(f"{FILE_PREFIX}*{storemenu.stem}*"):
            os.remove(file)

        # Process the files.
        colorprint(Style.BRIGHT + Fore.GREEN, f" -> Sorting StoreMenu files from DLC: {Fore.WHITE + directory.name}", "")
        sort_menu(storemenu, args.language, args.indent, args.debug)

        if args.inventory is True:

            # Remove all autogenerated files.
            for file in gamescripts.glob(f"{FILE_PREFIX}*{inventory.stem}"):
                os.remove(file)

            colorprint(Style.BRIGHT + Fore.GREEN, f" -> Sorting Inventory files from DLC: {Fore.WHITE + directory.name}", "")
            sort_menu(inventory, args.language, args.indent, args.debug)
