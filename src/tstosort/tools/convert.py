import argparse
from os import path
import xml.etree.ElementTree as ET
import locale
import re
from pathlib import Path
from natsort import natsorted
from operator import itemgetter
from colorama import Fore, Style, init


LANGUAGE_REQUIREMENTS = {
    "en": "ENG_US",
    "fr": "FRE_FR",
    "it": "ITA_IT",
    "de": "GER_DE",
    "es": "SPA_ES",
    "ko": "KOR_KR",
    "zh": "CHS_CN",
    "pt": "POR_BR",
    "ru": "RUS_RU",
    "tc": "CHT_CN",
    "da": "DAN_DK",
    "sv": "SWE_SE",
    "no": "NOR_NO",
    "du": "DUT_NL",
    "tr": "TUR_TR",
    "th": "THA_TH"
}


LOCALES = {
    "en": "en_US.UTF-8"}
#    "en": "en_US.UTF-8",
#    "da": "da_DK.ISO8859-1",
#    "de": "de_DE.ISO8859-1",
#    "es": "es_DO.ISO8859-1",
#    "fr": "fr_FR.ISO8859-1",
#    "it": "it_IT.ISO8859-1",
#    "ko": "ko_KR.eucKR",
#    "nl": "nl_NL.ISO8859-1",
#    "no": "no_NO.ISO8859-1",
#    "pt": "pt_BR.ISO8859-1",
#    "ru": "ru_RU.UTF-8",
#    "sv": "sv_SE.ISO8859-1",
#    "tc": "zh_CN.eucCN",
#    "th": "th_TH.TIS620",
#    "tr": "tr_TR.ISO8859-9",
#    "zh": "zh_CN.eucCN"
#}


SCORPIO_INDEX_PREFIX = {"bld_": "0", "cha_": "1", "mtx_": "6", "ui_": "14",  "": "15"}
SCORPIO_PREFIX_TYPES = {"building": "bld_", "character": "cha_"}
SCORPIO_FAKE_PREFIX_TYPES = {"consumable": "con_", "gameobjectbundle": "gob_"}


MASTERLISTS = {"building": "buildingmasterlist.xml", "character": "charactermasterlist.xml", "gameobjectbundle": "gameobjectbundlesmasterlist.xml", "consumable": "consumablemasterlist.xml"}
FILE_PREFIX = "autogenerated_"
CONTROL_VARIABLE_STOREMENU = "AUTOGENERATED_SORT_STOREMENU_ENABLE"


def colorprint(style, message, end="\n"):
    print(style + message, end=end)
    print(Style.RESET_ALL)



def get_textpool(directory, obj):

    # Open adequate masterlist file.
    id = int(obj.attrib["id"])
    obj_type = obj.attrib["type"].lower()
    name = obj.attrib["name"].lower()
    textpoolname = ""
    
    masterlist = Path(directory, MASTERLISTS[obj_type])
    tree = ET.parse(masterlist)
    root = tree.getroot()

    idmasterlist = root.find("IDMasterList")

    if idmasterlist is None:
        return {"prefix": "", "suffix": "*1"}

    for package in idmasterlist.findall("Package"):

        rangefrom = int(package.attrib.get("rangeFrom", "0"))
        rangeto = int(package.attrib.get("rangeTo", "0"))

        if rangefrom <= id and id <= rangeto:
            subtree = ET.parse(Path(directory, package.attrib["name"].lower() + ".xml"))
            subroot = subtree.getroot()

            elements = [element for element in subroot.findall("*") if element.tag.lower() == obj_type]

            for element in elements:
                if int(element.attrib["id"]) == id:
                    textpoolname = element.attrib.get("textpoolName")

                    if textpoolname is not None:

                        textpoolname = textpoolname.lower()

                        # Try to get prefix.
                        textpoolname_split = textpoolname.split("_", maxsplit = 1)
                        prefix = textpoolname_split[0] + "_"

                        if prefix in SCORPIO_INDEX_PREFIX:
                            return {"prefix": prefix, "suffix": textpoolname.strip(prefix)}

                        else:
                            return {"prefix": "", "suffix": textpoolname}


                    else:

                        prefix = SCORPIO_PREFIX_TYPES.get(obj_type, "")
                        suffix = name + "_name"

                        if prefix == "":
                            suffix = SCORPIO_FAKE_PREFIX_TYPES.get(obj_type, "") + suffix

                        return {"prefix": prefix, "suffix": suffix}


    # Fall back to this if no textpool can be determined.
    return {"prefix": "", "suffix": "*1"}




def get_item_name(directory, lang, obj):

    textpoolname = get_textpool(directory, obj)
    item_index = SCORPIO_INDEX_PREFIX[textpoolname["prefix"]]

    # Make sure to match the exact file.
    pattern = re.compile(f".*[^1]{item_index}.xml")

    for textpool_dir in Path(directory.parent).glob(f"*-{lang}"):
        for scorpio_file in textpool_dir.rglob(f"*{item_index}.xml"):

            if pattern.match(scorpio_file.name):

                with open(scorpio_file, "rb") as f:
                    root = ET.fromstring(f.read().decode("utf8"))

                    for group in root.findall("group"):

                        if group.attrib.get("prefix", "") == textpoolname["prefix"]:
                            for item in group.findall("item"):
                                if item.attrib.get("suffix", "") == textpoolname["suffix"]:
                                    return item.text


    # Fall back to this if no textpool can be determined.
    return "*1"




def map_objsets_to_objs(include, parent_dir):

    objsets = dict()

    if include.attrib["path"] is None:
        return objsets


    pathsplit = include.attrib["path"].split(":")
    submenu = Path(parent_dir, pathsplit[0].lower())

    if submenu.exists() is False:
        return objsets

    if pathsplit[-1].capitalize() != "Objects":
        return objsets


    subtree = ET.parse(submenu)
    subroot = subtree.getroot()


    objs = subroot

    for component in pathsplit[2:]:
        objs = objs.find(component) # type: ignore


    if objs is None:
        return objsets


    for objset in objs.findall("*"):

        obj = objset.find("Object")
        if obj is None:
            continue

        objsets[objset.attrib.get("name")] = obj


    return objsets



def get_items_from_category(directory, category, items, objsets, lang):


    for include in category.findall("Include"):
        objsets.update(map_objsets_to_objs(include, directory))


    # Add all listed objects and object sets.
    for obj in [element for element in category.findall("*") if element.tag.startswith("Object")]:
        sub_obj = obj

        if obj.tag != "Object":
            sub_obj = objsets.get(obj.attrib["name"])
            if sub_obj is None:
                continue

        item_name = get_item_name(directory, lang, sub_obj)
        items.append({"obj": obj, "subelements": list(), "name": item_name})



    # Include objects.
    for include in category.findall("Include"):
        subelements = list(include.findall("*"))

        if include.attrib["path"] is None:
            continue

        pathsplit = include.attrib["path"].split(":")
        include_file = Path(directory, pathsplit[0].lower())

        if include_file.exists() is False:
            continue

        if pathsplit[-1].capitalize() == "Objects":
            continue


        include_tree = ET.parse(include_file)
        include_root = include_tree.getroot()
        section = include_root

        for element in pathsplit[2:]:
            section = section.find(element) # type: ignore


        if section is None:
            continue


        # Add all listed objects and object sets.
        for obj in [element for element in section.findall("*") if element.tag.startswith("Object")]:
            sub_obj = obj

            if obj.tag != "Object":
                sub_obj = objsets.get(obj.attrib["name"])
                if sub_obj is None:
                    continue

            item_name = get_item_name(directory, lang, sub_obj)
            items.append({"obj": obj, "subelements": subelements, "name": item_name})


    return items


def main():
    parser = argparse.ArgumentParser(
        description="""
        This tool allows you to sort the storemenu files in alphabetically order for the game 'The Simpsons: Tapped Out'.
        """,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "-r",
        "--reverse",
        help="If set, reverse the order.",
        action="store_true",
    )

    parser.add_argument(
        "-i",
        "--indent",
        help="Indent level value used for xml files.",
        default=2,
        type=int,
    )

    parser.add_argument(
        "input_dir",
        help="List of the DLCs directories containing the gamescripts and textpools files.",
        nargs="+",
    )


    # Init colorama.
    init()

    args = parser.parse_args()
    directories = [Path(item) for item in args.input_dir]

    # Get total of DLCS to sort.
    total = len(directories)

    for i in range(len(directories)):

        directory = directories[i]

        # Process the files.
        colorprint(Style.BRIGHT + Fore.GREEN, f" -> Sorting files from DLC: {Fore.WHITE + directory.name}", "")

        storemenu = Path(directory, "gamescripts", "storemenu.xml")
        gamescripts = storemenu.parent

        if storemenu.exists() is True:

            load_tree = ET.parse(storemenu)
            load_root = load_tree.getroot()

            load_include = load_root.find("Include")

            if load_include is None:
                continue


            if load_include.attrib["path"] is None:
                continue


            pathsplit = load_include.attrib["path"].split(":")
            main_menu = Path(gamescripts, pathsplit[0].lower())


            if main_menu.exists() is False:
                continue


            main_tree = ET.parse(main_menu)
            main_root = main_tree.getroot()

            new_root = ET.Element("StoreMenus") 
            new_tree = ET.ElementTree(new_root)
            subelement = ET.SubElement(new_root, "Include", load_include.attrib)
            requirements = ET.SubElement(subelement, "Requirements")
            ET.SubElement(requirements, "Requirement", attrib = {"type": "formula", "formula": f"{CONTROL_VARIABLE_STOREMENU}==0"})


            # Iterate first over all objs.
            objsets = dict()
            for include in main_root.findall("Include"):
                objsets.update(map_objsets_to_objs(include, gamescripts))


            # With all objects read, iterate over all categories and includes and modify one by one per language.

            for lang in LOCALES.keys():

                colorprint(Style.BRIGHT + Fore.RED, " " * 1 * args.indent + f" - Language {Fore.YELLOW + lang}:", "")

                # Set locale.
                try:
                    locale.setlocale(locale.LC_COLLATE, LOCALES[lang])
                except locale.Error as e:
                    print(f"Locale setting {e} failed: {LOCALES[lang]}. Falling back to default Unicode sort.")

                for element in main_root.findall("*"):

                    if element.tag == "Category":

                        items = list()

                        if element.attrib.get("file") is None:
                            continue

                        submenu_file = Path(gamescripts, element.attrib["file"].lower())

                        if submenu_file.exists() is False:
                            continue


                        submenu_tree = ET.parse(submenu_file)
                        submenu_root = submenu_tree.getroot()

                        items = get_items_from_category(gamescripts, submenu_root, items, objsets, lang)

                        root = ET.Element(submenu_root.tag, submenu_root.attrib)
                        tree = ET.ElementTree(root)

                        # Sort all items.

                        for item in natsorted(items, key = itemgetter("name")):
                            obj = item["obj"]

                            # Add all subelements of this object.
                            for subelement in item["subelements"]:
                                obj.append(subelement)


                            root.append(obj)



                        # Create the new file.
                        target = Path(gamescripts, FILE_PREFIX + lang + "_" + submenu_file.name)
                        colorprint(Style.BRIGHT + Fore.LIGHTBLACK_EX, " " * 2 * args.indent + f" - {target.name}", "")

                        # Store tree.
                        ET.indent(tree, " " * args.indent)
                        tree.write(target)

                        element.attrib["file"] = str(target.name)


                    elif element.tag == "Include":


                        items = list()

                        if element.attrib.get("path") is None:
                            continue


                        pathsplit = element.attrib.get("path", "").split(":")

                        submenu_file = Path(gamescripts, pathsplit[0].lower())

                        if submenu_file.exists() is False:
                            continue


                        submenu_tree = ET.parse(submenu_file)
                        submenu_root = submenu_tree.getroot()
                        section = submenu_root

                        for component in pathsplit[2:]:
                            section = section.find(component) # type: ignore


                        if section is None:
                            continue


                        if section.tag.capitalize() != "Categories":
                            continue


                        root = ET.Element(submenu_root.tag, submenu_root.attrib)
                        tree = ET.ElementTree(root)


                        for category in section.findall("Category"):

                            items = get_items_from_category(gamescripts, category, items, objsets, lang)
                            new_category = ET.SubElement(root, category.tag, category.attrib)

                            # Sort all items.

                            for item in natsorted(items, key = itemgetter("name")):
                                obj = item["obj"]

                                # Add all subelements of this object.
                                for subelement in item["subelements"]:
                                    obj.append(subelement)


                                # Add element to sorted category.
                                new_category.append(obj)



                        # Create the new file.
                        target = Path(gamescripts, FILE_PREFIX + lang + "_" + submenu_file.name)
                        colorprint(Style.BRIGHT + Fore.LIGHTBLACK_EX, " " * 2 * args.indent + f" - {target.name}", "")


                        # Store tree.
                        ET.indent(tree, " " * args.indent)
                        tree.write(target)

                        element.attrib["path"] = ":".join([str(target.name)] + pathsplit[1:])


                # Store storemenu for this language.
                target = Path(gamescripts, FILE_PREFIX + lang + "_" + main_menu.name)
                ET.indent(main_tree, " " * args.indent)
                main_tree.write(target)


                # Include new file created for this language.
                subelement = ET.SubElement(new_root, "Include", {"path": str(target.name) + ":" + main_root.tag})

                # Add requirements.
                requirements = ET.SubElement(subelement, "Requirements")
                ET.SubElement(requirements, "Requirement", attrib = {"type": "formula", "formula": f"{CONTROL_VARIABLE_STOREMENU}==1"})
                ET.SubElement(requirements, "Requirement", attrib = {"type": "language", "language": LANGUAGE_REQUIREMENTS[lang]})



            # Store tree.
            ET.indent(new_tree, " " * args.indent)
            new_tree.write(storemenu)



